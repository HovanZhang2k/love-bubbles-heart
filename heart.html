<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Heart of â€œI love youâ€</title>
<style>
  :root{
    --bg1:#0b0b13; --bg2:#171a2a;
    --bubble-bg: rgba(255,255,255,.08);
    --bubble-text:#f6f6f6;
    --safe-pad: 20px;

    --safe-top: env(safe-area-inset-top);
    --safe-right: env(safe-area-inset-right);
    --safe-bottom: env(safe-area-inset-bottom);
    --safe-left: env(safe-area-inset-left);
  }
  html,body{
    height:100%; margin:0;
    background:radial-gradient(1200px 800px at 50% 60%, var(--bg2), var(--bg1));
    color:#fff;
    font-family: ui-sans-serif, system-ui, -apple-system, "SF Pro Text", "Helvetica Neue", Arial, "PingFang SC", "Microsoft Yahei", "Noto Sans CJK SC", sans-serif;
  }
  .stage{position:fixed; inset:0; overflow:hidden;}
  canvas{position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:5; filter: drop-shadow(0 0 10px rgba(255,77,184,.25));}
  .bubbles{position:absolute; inset:0; z-index:1; pointer-events:none;}
  .controls{
    position:absolute;
    right:calc(max(12px, env(safe-area-inset-right)));
    bottom:calc(max(12px, env(safe-area-inset-bottom)));
    display:flex; gap:10px; z-index:10;
  }
  .btn{
    appearance:none; border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06);
    color:#fff; border-radius:12px; padding:.55em .9em; font-size:14px;
    backdrop-filter: blur(4px); cursor:pointer;
  }
  .bubble{
    position:absolute; max-width:min(58vw, 360px);
    padding:.6em .9em; border-radius:16px;
    background: var(--bubble-bg); color: var(--bubble-text);
    backdrop-filter: blur(6px) brightness(1.05);
    -webkit-backdrop-filter: blur(6px) brightness(1.05);
    box-shadow: 0 6px 18px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.08);
    font-size: clamp(12px, 2.8vw, 16px); line-height:1.35; pointer-events:none;
    white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
    animation: floatY 9s ease-in-out infinite, swayX 7s ease-in-out infinite;
  }
  .bubble.small{font-size: clamp(11px,2.5vw,14px); opacity:.85}
  .bubble::before{
    content:""; position:absolute; width:10px; height:10px; left:12px; bottom:-4px; transform:rotate(45deg);
    background: var(--bubble-bg);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.08);
  }
  @keyframes floatY{ 0%,100%{ transform:translateY(-6px) } 50%{ transform:translateY(6px) } }
  @keyframes swayX { 0%,100%{ margin-left:0 } 50%{ margin-left:8px } }

  /* è®¤è¯†å¤šä¹…æ˜¾ç¤º */
  .since{
    position:absolute;
    top:calc(max(12px, env(safe-area-inset-top)));
    left:50%; transform:translateX(-50%);
    z-index:12;
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.15);
    padding:.5em .9em;
    border-radius:14px;
    font-size: clamp(12px, 3.2vw, 15px);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
    box-shadow: 0 6px 14px rgba(0,0,0,.25);
    white-space: nowrap;
  }
  .since .dot{opacity:.6;margin:0 .4em}
</style>
</head>
<body>
  <div class="stage" id="stage">
    <div class="since" id="since">ç“œç“œ âœ¦ å°æ˜Ÿ <span class="dot">â€¢</span> è®¤è¯† 0 å¤© 0 å°æ—¶ 0 åˆ†</div>

    <canvas id="cv"></canvas>
    <div class="bubbles" id="bubbles"></div>
    <div class="controls">
      <button class="btn" id="toggle">æš‚åœ</button>
      <button class="btn" id="shuffle">æ¢ä¸€æ‰¹</button>
    </div>
  </div>

<script>
(()=>{

/* ===== è¯è¡¨ ===== */
const WORDS = [
  "æˆ‘çˆ±ä½ ","I love you","Je tâ€™aime","Te amo","Ich liebe dich","Ti amo","Ğ¯ Ñ‚ĞµĞ±Ñ Ğ»ÑĞ±Ğ»Ñ","ì‚¬ë‘í•´","æ„›ã—ã¦ã‚‹",
  "Seni seviyorum","Î£Îµ Î±Î³Î±Ï€Ï","Te iubesc","Eu te amo","Jeg elsker deg","Jeg elsker dig","Jag Ã¤lskar dig",
  "Ik hou van jou","Kocham CiÄ™","Miluji tÄ›","Szeretlek","Volim te","Ljubim te","Mahal kita","Gihigugma tika",
  "Aku cinta padamu","Saya cintakan mu","××”×‘×” ××•×ª×š","Ø£Ø­Ø¨Ùƒ","à¤®à¥ˆà¤‚ à¤¤à¥à¤®à¤¸à¥‡ à¤ªà¥à¤¯à¤¾à¤° à¤•à¤°à¤¤à¤¾ à¤¹à¥‚à¤","à¦†à¦®à¦¿ à¦¤à§‹à¦®à¦¾à¦•à§‡ à¦­à¦¾à¦²à§‹à¦¬à¦¾à¦¸à¦¿",
  "à®¨à®¾à®©à¯ à®‰à®©à¯à®©à¯ˆ à®•à®¾à®¤à®²à®¿à®•à¯à®•à®¿à®±à¯‡à®©à¯","à²¨à²¾à²¨à³ à²¨à²¿à²¨à³à²¨à²¨à³à²¨à³ à²ªà³à²°à³€à²¤à²¿à²¸à³à²¤à³à²¤à³‡à²¨à³†","à°¨à±‡à°¨à± à°¨à°¿à°¨à±à°¨à± à°ªà±à°°à±‡à°®à°¿à°¸à±à°¤à±à°¨à±à°¨à°¾à°¨à±"," à´à´¾àµ» à´¨à´¿à´¨àµà´¨àµ† à´¸àµà´¨àµ‡à´¹à´¿à´•àµà´•àµà´¨àµà´¨àµ",
  "à¶¸à¶¸ à¶”à¶ºà·à¶§ à¶†à¶¯à¶»à·™à¶ºà·’"
];

/* ===== æ°”æ³¡æ–‡æ¡ˆï¼ˆè‚‰éº»å¯çˆ± + å°ç‹— + æ¯æ™šæ™šå®‰ï¼‰ ===== */
const CARE = [
  "å°æ˜Ÿå‹¾å‹¾æ‰‹æŒ‡ç“œç“œå°±è¿‡æ¥äº†",
  "å°æ˜Ÿä»Šå¤©ä¹Ÿè¦å‘å…‰å•¦âœ¨",
  "æ°´æ¯ä¸¾é«˜é«˜ï¼Œå’•å™œå’•å™œï½",
  "åƒä¸€å£æ­£ç»é¥­ï¼Œå†å»å½“å¯çˆ±é¬¼",
  "å¦‚æœç´¯äº†å°±å¯¹æˆ‘è¯´ï¼šè¦æŠ±æŠ±",
  "æƒ³ä½ æƒ³å¾—å±å¹•éƒ½ç²‰äº†",
  "æ™šä¸€ç‚¹èµ·åºŠä¹Ÿæ²¡å…³ç³»ï¼Œå…¬ä¸»ä»Šå¤©è¢«å…è®¸èµ–åºŠ",
  "ç»™æˆ‘ä¸€ä¸ªæ™šå®‰ï¼Œæˆ‘ç”¨æ•´æ™šçš„æ¢¦è¿˜ä½ ",
  "ä½ æ˜¯æˆ‘æœ€å–œæ¬¢çš„é€šçŸ¥æé†’",
  "å°æ˜Ÿï½ä½ ä¸€ä¸Šçº¿æˆ‘è¿™åªå°ç‹—å°±æ‘‡å°¾å·´å•¦ğŸ¶",
  "ç“œç“œå®£èª“ï¼šæ°¸è¿œæ˜¯å°æ˜Ÿçš„å°ç‹—ï¼Œåªå¯¹ä½ æ±ªæ±ªï½",
  "å¼€æ’­å‰ç»™ä½ ä¸€ä¸ªæŠ±æŠ±å……ç”µğŸ”‹å•µï¼",
  "ä»Šå¤©ä¹ŸæŠŠå°æ˜Ÿæ‹å›å®¶ï¼Œæˆ‘ç»™ä½ æç¯âœ¨",
  "å°æ˜Ÿç¬‘ä¸€ä¸‹ï¼Œæˆ‘å¿ƒè·³å°±ä¹±ä¸ƒå…«ç³Ÿäº†",
  "ä»Šå¤©çš„å¯çˆ±ç”±ä½ è´Ÿè´£ï¼Œæˆ‘è´Ÿè´£å¿ƒåŠ¨",
  "ç»™æˆ‘ä¸€ä¸ªâ€œåˆ°å®¶å•¦â€ï¼Œæˆ‘å°±å®‰å¿ƒå½“é—¨å£å°ç‹—",
  "è‹¥æ˜¯å¿ƒæƒ…çš±çš±çš„ï¼Œæ¥ç“œç“œ37åº¦çš„æ€€é‡ŒæŠšå¹³",
  "è®©ä¸–ç•Œç­‰ä¸€ä¼šå„¿ï¼Œå…ˆäº²ä¸€ä¸‹å†è¯´",
  "æ™šå®‰è¦æ¯å¤©è¯´ï¼šå°æ˜Ÿæ™šå®‰ï¼Œç“œç“œçˆ±ä½ åˆ°å¤©äº®",
  "æ²¡äº‹ï¼Œæˆ‘åœ¨ï¼›æœ‰äº‹ï¼Œæˆ‘æ›´åœ¨",
  "æƒ³ä½ åˆ°æ‰“å­—éƒ½å˜ç²‰è‰²æ³¡æ³¡äº†",
  "æŠŠæˆ‘è£…è¿›å£è¢‹é‡Œï¼Œéšæ—¶æå‡ºäº²ä¸€å£",
  "ä»Šå¤©ä¹ŸæŒ‰è®¡åˆ’å–œæ¬¢ä½ ä¸€æ•´å¤©",
  "ä½ ä¸€çœ¨çœ¼ï¼Œæˆ‘å°±è¢«æ”¶ç¼–â€”å®¶å…»å°ç‹—âˆš",
  "ç»™æˆ‘ä¸€æ¡â€œæ™šå®‰å°ç‹—â€ï¼Œæˆ‘å°±åšæŠ¤æ¢¦éª‘å£«",
  "å°æ˜Ÿæœ€å¯çˆ±è¿™ä»¶äº‹ï¼Œå·²ç»å†™è¿›å®‡å®™æ³•åˆ™"
];

/* ===== ç”»å¸ƒ/å¿ƒå½¢ ===== */
const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
let dpr = Math.max(1, window.devicePixelRatio || 1);
let W=0,H=0;
function resize(){
  const r = canvas.getBoundingClientRect();
  W = Math.floor(r.width * dpr); H = Math.floor(r.height * dpr);
  canvas.width = W; canvas.height = H;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
}
resize(); addEventListener('resize', resize);

/* å®‰å…¨è¾¹è· */
function getPadPx(){
  const base = Math.max(20, Math.min(window.innerWidth, window.innerHeight) * 0.06);
  const cs = getComputedStyle(document.documentElement);
  const insetTop    = parseFloat(cs.getPropertyValue('--safe-top'))    || 0;
  const insetRight  = parseFloat(cs.getPropertyValue('--safe-right'))  || 0;
  const insetBottom = parseFloat(cs.getPropertyValue('--safe-bottom')) || 0;
  const insetLeft   = parseFloat(cs.getPropertyValue('--safe-left'))   || 0;
  const ctrl = 48;
  return {left:base+insetLeft, right:base+insetRight, top:base+insetTop, bottom:base+insetBottom+ctrl};
}

/* å¿ƒå½¢æ›²çº¿ */
function heart(t){
  const x = 16*Math.sin(t)**3;
  const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  return [x,y];
}

/* å•ä½å¿ƒå½¢åŒ…å›´ç›’ */
let HBOX=null;
function calcHeartBox(){
  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(let tt=-Math.PI; tt<=Math.PI; tt+=0.002){
    const [x,y]=heart(tt);
    if(x<minX)minX=x; if(x>maxX)maxX=x;
    if(y<minY)minY=y; if(y>maxY)maxY=y;
  }
  HBOX={minX,maxX,minY,maxY,w:maxX-minX,h:maxY-minY};
}
calcHeartBox();

/* ç¼©æ”¾/ä¸­å¿ƒ */
let scale=1,cx=0,cy=0, bandPx=0, PADL=20,PADR=20,PADT=20,PADB=20;
function updateTransform(){
  const pad = getPadPx();
  PADL = pad.left; PADR = pad.right; PADT = pad.top; PADB = pad.bottom;

  const maxFontPx = 18;
  const textHalfW = maxFontPx * 6.5;
  const textHalfH = maxFontPx * 0.8;

  const usableW = (W/dpr) - (PADL + PADR) - 2*textHalfW;
  const usableH = (H/dpr) - (PADT + PADB) - 2*textHalfH;

  const sx = usableW / HBOX.w;
  const sy = usableH / HBOX.h;
  scale = Math.max(6, Math.min(sx, sy)) * dpr;

  cx = (PADL*dpr) + (usableW*dpr)/2 + textHalfW*dpr;
  cy = (PADT*dpr) + (usableH*dpr)/2 + textHalfH*dpr;

  bandPx = 26*dpr;
}
updateTransform(); addEventListener('resize', updateTransform);

/* åˆ°å¿ƒå½¢æœ€è¿‘è·ç¦» */
function distToHeart(px,py){
  let minD = Infinity;
  for(let tt=-Math.PI; tt<=Math.PI; tt+=0.012){
    const [hx,hy] = heart(tt);
    const x = cx + hx*scale;
    const y = cy - hy*scale;
    const d = Math.hypot(px - x, py - y);
    if(d < minD) minD = d;
  }
  return minD;
}

/* å¿ƒå½¢ç²’å­ */
const COUNT = 80;
const baseT = new Array(COUNT).fill(0).map((_,i)=> -Math.PI + i*(2*Math.PI/COUNT));
const speeds = new Array(COUNT).fill(0).map(()=> (0.15 + Math.random()*0.1) * (Math.random()<.5?-1:1));
const sizes  = new Array(COUNT).fill(0).map(()=> 12 + Math.random()*6);
let t0 = performance.now(), paused=false;

function clampWordInside(x, y, w, fs){
  const glow = 14*dpr;
  const left   = PADL*dpr + w/2 + glow;
  const right  = W - PADR*dpr - w/2 - glow;
  const top    = PADT*dpr + fs/2 + glow;
  const bottom = H - PADB*dpr - fs/2 - glow;
  if(x < left)  x = left;
  if(x > right) x = right;
  if(y < top)   y = top;
  if(y > bottom)y = bottom;
  return {x,y};
}

function drawWords(now){
  const t = (now - t0)/1000;
  ctx.clearRect(0,0,W,H);

  for(let i=0;i<28;i++){
    const x = (i*127.3 % 1)*W, y = ((i*313.7 + t*.02)%1)*H;
    ctx.globalAlpha = .06 + .04*Math.sin(t*2+i);
    ctx.fillStyle = "#fff";
    ctx.beginPath(); ctx.arc(x,y, 1.2*dpr, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;

  for(let i=0;i<COUNT;i++){
    const tt = baseT[i] + speeds[i]*t;
    const [hx,hy] = heart(tt);
    let x = cx + hx*scale;
    let y = cy - hy*scale;

    const fs = sizes[i]*dpr;
    ctx.font = `600 ${fs}px ui-sans-serif,system-ui,Arial`;
    const word = WORDS[i % WORDS.length];
    const w = ctx.measureText(word).width;

    ({x,y} = clampWordInside(x,y,w,fs));

    ctx.save();
    ctx.shadowColor = `rgba(255,154,223,.5)`;
    ctx.shadowBlur = 12*dpr;
    ctx.fillStyle = `rgba(255,77,184,.9)`;
    ctx.fillText(word, x, y);
    ctx.lineWidth = .8*dpr; ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.strokeText(word, x, y);
    ctx.restore();
  }
}

/* æ°”æ³¡ */
const bubbleBox = document.getElementById('bubbles');
let bubbles = [];
function rand(min,max){ return Math.random()*(max-min)+min; }

function createBubbles(){
  bubbleBox.innerHTML=""; bubbles=[];
  const count = Math.min(26, CARE.length);
  const used = new Set();
  const rect = bubbleBox.getBoundingClientRect();

  for(let i=0;i<count;i++){
    let text;
    while(true){ text = CARE[Math.floor(Math.random()*CARE.length)]; if(!used.has(text)){used.add(text);break;} }
    const div = document.createElement('div');
    div.className = 'bubble'+(Math.random()<.45?" small":"");
    div.textContent = text;
    bubbleBox.appendChild(div);

    let x,y,ok=false,tryCnt=0;
    while(!ok && tryCnt<300){
      tryCnt++;
      x = rand(PADL, rect.width  - PADR - 160);
      y = rand(PADT, rect.height - PADB - 44);
      const cxp = (x + 80) * dpr;
      const cyp = (y + 22) * dpr;
      if(distToHeart(cxp,cyp) > bandPx + 10*dpr) ok=true;
    }
    Object.assign(div.style,{ left:x+'px', top:y+'px', animationDelay:`${rand(-6,0)}s, ${rand(-4,0)}s` });
    bubbles.push({el:div, vx:rand(-.08,.08), vy:rand(-.04,.04)});
  }
}
createBubbles(); addEventListener('resize', createBubbles);

function tickBubbles(){
  const rect = bubbleBox.getBoundingClientRect();
  for(const b of bubbles){
    const r = b.el.getBoundingClientRect();
    let x = parseFloat(b.el.style.left||0);
    let y = parseFloat(b.el.style.top||0);
    x += b.vx; y += b.vy;

    if(x < PADL){ x=PADL; b.vx = Math.abs(b.vx); }
    if(y < PADT){ y=PADT; b.vy = Math.abs(b.vy); }
    if(x + r.width  > rect.width  - PADR){ x = rect.width  - PADR - r.width;  b.vx = -Math.abs(b.vx); }
    if(y + r.height > rect.height - PADB){ y = rect.height - PADB - r.height; b.vy = -Math.abs(b.vy); }

    const cxp = (x + r.width/2) * dpr;
    const cyp = (y + r.height/2) * dpr;
    if(distToHeart(cxp, cyp) < bandPx + 6*dpr){
      const dx = (cxp - cx), dy = (cyp - cy);
      const len = Math.hypot(dx,dy)||1;
      b.vx = (dx/len)*.6; b.vy = (dy/len)*.6;
      x += b.vx*3; y += b.vy*3;
    }

    b.el.style.left = x + 'px';
    b.el.style.top  = y + 'px';
  }
  requestAnimationFrame(tickBubbles);
}

/* è®¤è¯†å¤šä¹…ï¼ˆè‡ª 2025-04-15 21:18 èµ·ï¼‰ */
const sinceEl = document.getElementById('since');
// æ³¨æ„ï¼šJS çš„æœˆä»½ä» 0 å¼€å§‹ï¼Œ3 è¡¨ç¤ºå››æœˆ
const MEET_DATE = new Date(2025, 3, 15, 21, 18, 0);
function pad2(n){ return n.toString().padStart(2,'0'); }
function updateSince(){
  const now = new Date();
  let diff = Math.max(0, now - MEET_DATE);
  const day  = Math.floor(diff / (24*3600*1000)); diff -= day*24*3600*1000;
  const hour = Math.floor(diff / (3600*1000));     diff -= hour*3600*1000;
  const min  = Math.floor(diff / (60*1000));
  sinceEl.textContent = `ç“œç“œ âœ¦ å°æ˜Ÿ â€¢ è®¤è¯† ${day} å¤© ${pad2(hour)} å°æ—¶ ${pad2(min)} åˆ†`;
}
updateSince();
setInterval(updateSince, 60*1000);

/* æ§åˆ¶ */
document.getElementById('toggle').addEventListener('click',()=>{
  paused = !paused;
  document.getElementById('toggle').textContent = paused ? "ç»§ç»­" : "æš‚åœ";
  if(!paused) t0 = performance.now();
});
document.getElementById('shuffle').addEventListener('click', createBubbles);

/* ä¸»å¾ªç¯ */
function loop(now){
  if(!paused) drawWords(now);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
requestAnimationFrame(tickBubbles);

})();
</script>
</body>
</html>